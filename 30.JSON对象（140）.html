<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>json对象</title>
    <script>
        /*
        * JSON
        *   - JS中的对象只有JS自己认识，其他的语言都不认识
        *   - JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，
        *       并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互
        *   - JSON
        *       - Javascript Object Notation JS对象表示法
        *       - JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号。
        *           其他的和JS语法一致
        *         JSON分类：
        *               1.对象{}
        *               2.数组[]
        *         JSON中允许的值：
        *           1.字符串
        *           2.数值
        *           3.布尔值
        *           4.null
        *           5.对象（这里指的是普通对象，不包括函数）
        *           6.数组
        * */
        //创建一个对象
        var obj='{"name":"孙悟空","age":"18","gender":"男"}';
        var arr= '[1,2,3,"hello",true]';

        /*
        * json --> JS对象
        *   JSON.parse()
        *       - 可以将以JSON字符串转换为JS对象
        *       - 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象
        * */

        var obj3 ={name:"猪八戒",age:28,gender:"男"};
        /*
        * JS对象---> JSON
        * JSON.stringify()
        *   - 可以将一个JS对象转换为JSON字符串
        *   - 需要一个JS对象作为参数，会返回一个JSON字符串
        *
        * */
        var str=JSON.stringify(obj3);
        console.log(typeof str);
        /*JSON在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错。
        * */

        /*
        * eval()
        *   - 这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回。
        *   - 如果使用eval()执行的字符串中含有{}，它会将{}当成是代码块，
        *       如果不希望将其当成代码块解析，则需要在字符串前后各加一个()
        *
        *   - eval()这个函数的功能很强大，可以直接执行一个字符串中的JS代码，
        *       但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患。
        * */
        var str2="alert('我是eval执行的结果')";
        eval(str2);
        var str3='{"name":"孙悟空","age":"18","gender":"男"}';
        console.log(eval("("+str3+")"));


        var o = {
            a: 2,
            m: function(){
                return this.a + 1;
            }
        };
        console.log(o.m()); // 3
        var p = Object.create(o);
        p.a = 4; // 创建 p 的自身属性 'a'
        console.log(p.m()); // 5


        var tmp = new Date();

        function f() {
            console.log(tmp);// undefined
            if (false) {
                var tmp = 'hello world';
            }
        }
        f(); // undefined
        console.log(tmp);

        function f1() {
            var n = 5;
            if (true) {
                var n = 10;
            }
            console.log(n); // 10    如果把n改变为let的定义的话，则输出的是5
        }
        f1();


    /*    (function () {
            if (false) {
                // 重复声明一次函数f
                function f() { console.log('I am inside!'); }
            }
            /!*
            * ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
            * *!/
            f();  //这里会报错
        }());*/


        /*// 浏览器的 ES6 环境
        function f() { console.log('I am outside!'); }

        (function () {
            if (false) {
                // 重复声明一次函数f
                function f() { console.log('I am inside!'); }
            }

            f();
        }());*/

  /*      const foo;  //只声明不赋值就会报错
        console.log(foo);*/

        const a = [];
        a.push('Hello'); // 可执行
        a.push('111'); // 可执行
        console.log(a);
        /*      a.length = 0;    // 可执行
              a = ['Dave'];    // 报错*/

        y = 2;
        console.log(y);


        //let [x = 5] = [undefined];
        //x // 1
        //console.log(x);

   /*     let [x = 1] = [null];
        function aaa(){
            console.log(x);
        }
        aaa();*/

        let x;
        if ([1][0] === undefined) {
            x = f();
        } else {
            x = [1][0];
        }
        console.log(x);


        const { log } = console;
        log('hello'); // hello

        /*
        * 注意，这时P是模式，不是变量，因此不会被赋值。如果P也要作为变量赋值，可以写成下面这样。
        * */
        let obj1 = {
            P: [
                'Hello',
                { Y: 'World' }
            ]
        };

        let { P, P: [x1, { Y }] } = obj1;
        console.log(P); //["Hello", {y: "World"}]   x="Hello"   y="World"


        const node = {
            loc: {
                start: {
                    line: 1,
                    column: 5
                }
            }
        };

        /*
        * 以下代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。
        * 注意，最后一次对line属性的解构赋值之中，
        * 只有line是变量，loc和start都是模式，不是变量。
        * */
        let { loc, loc: { start }, loc: { start: { line }} } = node;
        console.log( loc);
        console.log( start);
        console.log("line=" + line);


        let obj2 = {};
        let arr2 = [];

        ({ foo1: obj2.prop, bar1: arr2[0] } = { foo1: 123, bar1: true });
        console.log(arr2);


        var {x0: y0 = 3} = {};
        console.log(y0);

        let {length : len} = 'hello';
        console.log(len); //5

        let {toString: ss} = 123;
        console.log(ss);


    </script>
</head>
<body>

</body>
</html>